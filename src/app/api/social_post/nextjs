// src/api/tweet/route.ts
import { NextResponse } from 'next/server';

export const config = {
  api: {
    bodyParser: false,
  },
};

export async function POST(request: Request) {
  // Parse multipart form data
  const formData = await request.formData();
  const userToken = formData.get('access_token')?.toString();
  const text = formData.get('text')?.toString();
  const file = formData.get('image') as Blob | null;

  if (!userToken || !text || !file) {
    return NextResponse.json(
      { error: 'access_token, text and image are required' },
      { status: 400 }
    );
  }

  // Read file bytes
  const arrayBuffer = await file.arrayBuffer();
  const mediaData = Buffer.from(arrayBuffer);

  try {
    // 1) Upload image bytes to Twitter v2 media endpoint
    const uploadRes = await fetch('https://api.twitter.com/2/media/upload', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${userToken}`,
        'Content-Type': 'application/octet-stream',
        'Content-Length': mediaData.length.toString(),
      },
      body: mediaData,
    });

    if (!uploadRes.ok) {
      const err = await uploadRes.json();
      return NextResponse.json(err, { status: uploadRes.status });
    }
    const { media_id: mediaId } = await uploadRes.json();

    // 2) Post tweet referencing uploaded media
    const tweetRes = await fetch('https://api.twitter.com/2/tweets', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${userToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ text, media: { media_ids: [mediaId] } }),
    });

    const tweetData = await tweetRes.json();
    return NextResponse.json(tweetData, { status: tweetRes.status });
  } catch (err: any) {
    return NextResponse.json(
      { error: err.message || 'Unknown error' },
      { status: 500 }
    );
  }
}
